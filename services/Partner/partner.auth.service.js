// services/Partner/partner.auth.service.js - –ò–°–ü–†–ê–í–õ–ï–ù–ù–´–ô –ë–ï–ó –î–£–ë–õ–ò–†–û–í–ê–ù–ò–Ø
import jwt from "jsonwebtoken";
import { User, PartnerProfile, InitialPartnerRequest, PartnerLegalInfo } from '../../models/index.js';
import Meta from '../../models/Meta.model.js';
import { hashString, hashMeta, comparePassword } from '../../utils/hash.js';
import { cryptoString } from '../../utils/crypto.js';
import { generateCustomerToken } from '../token.service.js';
import { mockGeocode } from '../../utils/address.utils.js'; // ‚úÖ –ò–°–ü–û–õ–¨–ó–£–ï–ú –£–¢–ò–õ–ò–¢–£
import mongoose from 'mongoose';

/**
 * ================== –°–û–ó–î–ê–ù–ò–ï –ê–ö–ö–ê–£–ù–¢–ê –ü–ê–†–¢–ù–ï–†–ê ==================
 */
const createPartnerAccount = async (data) => {
    const {
        first_name, last_name, email, password, phone,
        business_name, brand_name, category, address, floor_unit,
        whatsapp_consent
    } = data;

    const session = await mongoose.startSession();
    
    try {
        let result = null;
        
        await session.withTransaction(async () => {
            const normalizedEmail = email.toLowerCase().trim();

            // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–∞—Ä—Ç–Ω–µ—Ä–∞
            const existingMeta = await Meta.findOne({
                em: hashMeta(normalizedEmail),
                role: 'partner'
            });

            if (existingMeta) {
                throw new Error('–ü–∞—Ä—Ç–Ω–µ—Ä —Å —Ç–∞–∫–∏–º email —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç');
            }

            // ‚úÖ –ê–í–¢–û–ú–ê–¢–ò–ß–ï–°–ö–û–ï –ì–ï–û–ö–û–î–ò–†–û–í–ê–ù–ò–ï –ê–î–†–ï–°–ê
            console.log('üó∫Ô∏è GEOCODING ADDRESS:', address);
            const geocodeResult = mockGeocode(address);
            
            if (!geocodeResult.success) {
                throw new Error('–û—à–∏–±–∫–∞ –≥–µ–æ–∫–æ–¥–∏—Ä–æ–≤–∞–Ω–∏—è –∞–¥—Ä–µ—Å–∞: ' + geocodeResult.error);
            }

            const coordinates = geocodeResult.coordinates;
            console.log('‚úÖ GEOCODING SUCCESS:', coordinates);

            // –°–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
            const newUser = new User({
                email: cryptoString(normalizedEmail), // ‚úÖ –î–û–ë–ê–í–õ–Ø–ï–ú –ó–ê–®–ò–§–†–û–í–ê–ù–ù–´–ô EMAIL
                role: 'partner',
                is_email_verified: false,
                is_active: true,
                password_hash: await hashString(password),
                created_at: new Date(),
                last_login_at: null
            });

            await newUser.save({ session });

            // –°–æ–∑–¥–∞–µ–º Meta –∑–∞–ø–∏—Å—å
            const newMeta = new Meta({
                em: hashMeta(normalizedEmail),
                role: 'partner',
                partner: newUser._id,
                is_active: true,
                failed_attempts: 0,
                last_failed_attempt: null,
                account_locked_until: null
            });

            await newMeta.save({ session });

            // –®–∏—Ñ—Ä—É–µ–º –ø–µ—Ä—Å–æ–Ω–∞–ª—å–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ
            const encryptedPersonalData = {
                first_name: cryptoString(first_name),
                last_name: cryptoString(last_name),
                email: cryptoString(normalizedEmail),
                phone: cryptoString(phone)
            };

            // –®–∏—Ñ—Ä—É–µ–º –±–∏–∑–Ω–µ—Å –¥–∞–Ω–Ω—ã–µ
            const encryptedBusinessData = {
                business_name: cryptoString(business_name),
                brand_name: cryptoString(brand_name) || '',
                category: category,
                address: cryptoString(address),
                floor_unit: floor_unit ? cryptoString(floor_unit) : null,
                location: {
                    type: 'Point',
                    coordinates: [coordinates.lng, coordinates.lat] // GeoJSON: [longitude, latitude]
                },
                delivery_zones: [{
                    zone_number: coordinates.zone,
                    max_distance_km: coordinates.zone === 1 ? 5 : 10,
                    delivery_fee: coordinates.zone === 1 ? 2.99 : 4.99,
                    min_order_amount: 30,
                    is_active: true
                }],
                // ‚úÖ –ò–°–ü–†–ê–í–õ–ï–ù–û: owner_name –∏ owner_surname –í–ù–£–¢–†–ò business_data
                  owner_name: cryptoString(first_name),      // ‚úÖ –ó–ê–®–ò–§–†–û–í–ê–ù–ù–û
                  owner_surname: cryptoString(last_name)
            };

            // –°–æ–∑–¥–∞–µ–º –∑–∞—è–≤–∫—É –ø–∞—Ä—Ç–Ω–µ—Ä–∞
            const savedRequest = new InitialPartnerRequest({
                user_id: newUser._id,
                personal_data: encryptedPersonalData,
                business_data: encryptedBusinessData,
                // ‚ùå –£–ë–ò–†–ê–ï–ú - owner_name –∏ owner_surname —Ç–µ–ø–µ—Ä—å –≤ business_data
                marketing_consent: {
                    whatsapp_consent: whatsapp_consent || false
                },
                status: 'pending',
                workflow_stage: 1,
                submitted_at: new Date()
            });

            await savedRequest.save({ session });

            // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–æ–∫–µ–Ω –ë–ï–ó email (–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ)
            const token = generateCustomerToken({
                _id: newUser._id,
                user_id: newUser._id,
                role: 'partner'
            }, '30d');

            result = {
                token,
                user: {
                    id: newUser._id,
                    role: 'partner'
                },
                request: savedRequest,
                coordinates: coordinates // ‚úÖ –í–û–ó–í–†–ê–©–ê–ï–ú –ö–û–û–†–î–ò–ù–ê–¢–´
            };
        });

        return result;

    } catch (error) {
        console.error('üö® CREATE PARTNER ACCOUNT ERROR:', error);
        throw error;
    } finally {
        await session.endSession();
    }
};

/**
 * ================== –ê–í–¢–û–†–ò–ó–ê–¶–ò–Ø –ü–ê–†–¢–ù–ï–†–ê ==================
 */
const loginPartner = async (email, password) => {
    try {
        const normalizedEmail = email.toLowerCase().trim();
        
        // –ò—â–µ–º —á–µ—Ä–µ–∑ Meta
        const metaInfo = await Meta.findOne({
            em: hashMeta(normalizedEmail),
            role: 'partner'
        }).populate('partner');

        if (!metaInfo || !metaInfo.partner) {
            const error = new Error('–ü–∞—Ä—Ç–Ω–µ—Ä –Ω–µ –Ω–∞–π–¥–µ–Ω');
            error.statusCode = 404;
            throw error;
        }

        const partner = metaInfo.partner;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –∞–∫–∫–∞—É–Ω—Ç–∞
        if (!partner.is_active) {
            const error = new Error('–ê–∫–∫–∞—É–Ω—Ç –¥–µ–∞–∫—Ç–∏–≤–∏—Ä–æ–≤–∞–Ω');
            error.statusCode = 403;
            throw error;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–ª–æ–∫–∏—Ä–æ–≤–∫—É –∞–∫–∫–∞—É–Ω—Ç–∞
        if (metaInfo.isAccountLocked && metaInfo.isAccountLocked()) {
            const error = new Error('–ê–∫–∫–∞—É–Ω—Ç –≤—Ä–µ–º–µ–Ω–Ω–æ –∑–∞–±–ª–æ–∫–∏—Ä–æ–≤–∞–Ω –∏–∑-–∑–∞ –º–Ω–æ–∂–µ—Å—Ç–≤–µ–Ω–Ω—ã—Ö –Ω–µ—É–¥–∞—á–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫ –≤—Ö–æ–¥–∞');
            error.statusCode = 423;
            throw error;
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø–∞—Ä–æ–ª—å
        const isPasswordValid = await comparePassword(password, partner.password_hash);
        
        if (!isPasswordValid) {
            await metaInfo.incrementFailedAttempts();
            const error = new Error('–ù–µ–≤–µ—Ä–Ω—ã–π –ø–∞—Ä–æ–ª—å');
            error.statusCode = 401;
            throw error;
        }

        // –°–±—Ä–∞—Å—ã–≤–∞–µ–º —Å—á–µ—Ç—á–∏–∫ –Ω–µ—É–¥–∞—á–Ω—ã—Ö –ø–æ–ø—ã—Ç–æ–∫ –ø—Ä–∏ —É—Å–ø–µ—à–Ω–æ–º –≤—Ö–æ–¥–µ
        await metaInfo.resetFailedAttempts();

        // –û–±–Ω–æ–≤–ª—è–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
        partner.last_login_at = new Date();
        await partner.save();

        // –ü–æ–ª—É—á–∞–µ–º –ø—Ä–æ—Ñ–∏–ª—å
        const profile = await PartnerProfile.findOne({ user_id: partner._id });

        // –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–æ–∫–µ–Ω –ë–ï–ó EMAIL (–ø–æ—Å–ª–µ–¥–æ–≤–∞—Ç–µ–ª—å–Ω–æ)
        const token = generateCustomerToken({
            _id: partner._id,
            user_id: partner._id,
            role: 'partner'
        }, '30d');

        return {
            token,
            partner: {
                id: partner._id,
                role: partner.role,
                is_email_verified: partner.is_email_verified,
                is_active: partner.is_active,
                profile: profile
            }
        };

    } catch (error) {
        throw error;
    }
};

/**
 * ================== –í–ï–†–ò–§–ò–ö–ê–¶–ò–Ø –¢–û–ö–ï–ù–ê ==================
 */
const verifyPartnerToken = async (token) => {
    try {
        // –î–µ–∫–æ–¥–∏—Ä—É–µ–º —Ç–æ–∫–µ–Ω
        const decoded = jwt.verify(token, process.env.JWT_SECRET);
        const { user_id, _id, role } = decoded;
        const partnerId = user_id || _id;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–æ–ª—å
        if (role !== "partner") {
            return { 
                success: false,
                message: "Access denied! Not a partner account!", 
                statusCode: 403 
            };
        }

        // –ò—â–µ–º —á–µ—Ä–µ–∑ Meta —Å populate
        const metaInfo = await Meta.findOne({
            partner: partnerId,
            role: "partner"
        }).populate("partner");

        if (!metaInfo || !metaInfo.partner) {
            return { 
                success: false,
                message: "Access denied! Partner not found!", 
                statusCode: 404 
            };
        }

        const partner = metaInfo.partner;

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
        if (!metaInfo.is_active || !partner.is_active) {
            return {
                success: false,
                message: "Access denied! Account is inactive!",
                statusCode: 403
            };
        }

        // –ü—Ä–æ–≤–µ—Ä—è–µ–º –±–ª–æ–∫–∏—Ä–æ–≤–∫—É
        if (metaInfo.isAccountLocked && metaInfo.isAccountLocked()) {
            return {
                success: false,
                message: "Access denied! Account is locked!",
                statusCode: 423
            };
        }

        return { 
            success: true,
            message: "Access approved!", 
            partner: partner,
            metaInfo: metaInfo
        };

    } catch (err) {
        if (err.name === 'TokenExpiredError') {
            return { success: false, message: "Access denied! Token expired!", statusCode: 401 };
        } else if (err.name === 'JsonWebTokenError') {
            return { success: false, message: "Access denied! Token invalid!", statusCode: 401 };
        } else {
            return { success: false, message: "Access denied! Token error!", statusCode: 401 };
        }
    }
};

/**
 * ================== –ü–†–û–í–ï–†–ö–ê –°–£–©–ï–°–¢–í–û–í–ê–ù–ò–Ø ==================
 */
const checkPartnerExists = async (email) => {
    try {
        const normalizedEmail = email.toLowerCase().trim();
        
        const existingMeta = await Meta.findOne({
            em: hashMeta(normalizedEmail),
            role: 'partner'
        });
        
        return !!existingMeta;
        
    } catch (error) {
        console.error('üö® CHECK PARTNER EXISTS - Error:', error);
        return false;
    }
};

export { 
    createPartnerAccount,
    loginPartner,
    verifyPartnerToken,
    checkPartnerExists 
};