// services/Public/public.service.js - –ó–ê–í–ï–†–®–ï–ù–ù–´–ô –ø—É–±–ª–∏—á–Ω—ã–π —Å–µ—Ä–≤–∏—Å –∫–∞—Ç–∞–ª–æ–≥–∞
import { PartnerProfile, Product, Category } from '../../models/index.js';
import mongoose from 'mongoose';

/**
 * üè™ –ü–û–õ–£–ß–ò–¢–¨ –ö–ê–¢–ê–õ–û–ì –†–ï–°–¢–û–†–ê–ù–û–í (–ø—É–±–ª–∏—á–Ω—ã–π –¥–æ—Å—Ç—É–ø)
 * –û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è –≥–ª–∞–≤–Ω–æ–π —Å—Ç—Ä–∞–Ω–∏—Ü—ã –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è
 */
export const getPublicRestaurantCatalog = async (filters = {}) => {
  try {
    const {
      category = null,
      search = null,
      lat = null,
      lng = null,
      radius = 10, // –∫–º
      sort_by = 'popular', // popular, rating, distance, newest
      is_open_now = null,
      min_rating = null,
      delivery_fee_max = null,
      limit = 20,
      offset = 0
    } = filters;

    console.log('üè™ GET PUBLIC CATALOG:', {
      category,
      search: search ? search.substring(0, 20) : null,
      coordinates: lat && lng ? `${lat},${lng}` : null,
      sort_by,
      filters_count: Object.keys(filters).length
    });

    // –ë–∞–∑–æ–≤—ã–π —Ñ–∏–ª—å—Ç—Ä - —Ç–æ–ª—å–∫–æ –∞–∫—Ç–∏–≤–Ω—ã–µ –∏ –æ–¥–æ–±—Ä–µ–Ω–Ω—ã–µ —Ä–µ—Å—Ç–æ—Ä–∞–Ω—ã
    let mongoFilter = {
      is_active: true,
      is_approved: true,
      profile_status: 'approved'
    };

    // –§–∏–ª—å—Ç—Ä –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏
    if (category && category !== 'all') {
      mongoFilter.category = category;
    }

    // –ü–æ–∏—Å–∫ –ø–æ —Ç–µ–∫—Å—Ç—É (–Ω–∞–∑–≤–∞–Ω–∏–µ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞, –æ–ø–∏—Å–∞–Ω–∏–µ, –∫—É—Ö–Ω—è)
    if (search && search.trim()) {
      const searchRegex = new RegExp(search.trim(), 'i');
      mongoFilter.$or = [
        { business_name: searchRegex },
        { description: searchRegex },
        { category: searchRegex },
        { cuisine_types: { $in: [searchRegex] } },
        { 'business_info.tags': { $in: [searchRegex] } }
      ];
    }

    // –§–∏–ª—å—Ç—Ä –ø–æ —Ä–µ–π—Ç–∏–Ω–≥—É
    if (min_rating && min_rating > 0) {
      mongoFilter['ratings.average_rating'] = { $gte: parseFloat(min_rating) };
    }

    // –§–∏–ª—å—Ç—Ä –ø–æ –º–∞–∫—Å–∏–º–∞–ª—å–Ω–æ–π —Å—Ç–æ–∏–º–æ—Å—Ç–∏ –¥–æ—Å—Ç–∞–≤–∫–∏
    if (delivery_fee_max !== null && delivery_fee_max >= 0) {
      mongoFilter['delivery_info.delivery_fee'] = { $lte: parseFloat(delivery_fee_max) };
    }

    // –§–∏–ª—å—Ç—Ä –ø–æ –≤—Ä–µ–º–µ–Ω–∏ —Ä–∞–±–æ—Ç—ã (–µ—Å–ª–∏ —Ä–µ—Å—Ç–æ—Ä–∞–Ω —Å–µ–π—á–∞—Å –æ—Ç–∫—Ä—ã—Ç)
    if (is_open_now === true || is_open_now === 'true') {
      const now = new Date();
      const currentDay = now.toLocaleDateString('en-US', { weekday: 'lowercase' });
      const currentTime = now.toTimeString().slice(0, 5); // HH:MM —Ñ–æ—Ä–º–∞—Ç

      mongoFilter[`working_hours.${currentDay}.is_open`] = true;
      mongoFilter.$expr = {
        $and: [
          { $lte: [`$working_hours.${currentDay}.open_time`, currentTime] },
          { $gte: [`$working_hours.${currentDay}.close_time`, currentTime] }
        ]
      };
    }

    // –ì–µ–æ—Ñ–∏–ª—å—Ç—Ä (–µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω—ã –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã)
    if (lat && lng && radius > 0) {
      const radiusInDegrees = radius / 111; // –ü—Ä–∏–º–µ—Ä–Ω–æ–µ –ø—Ä–µ–æ–±—Ä–∞–∑–æ–≤–∞–Ω–∏–µ –∫–º –≤ –≥—Ä–∞–¥—É—Å—ã
      
      mongoFilter['location.coordinates'] = {
        $geoWithin: {
          $centerSphere: [[parseFloat(lng), parseFloat(lat)], radius / 6378.1] // –†–∞–¥–∏—É—Å –ó–µ–º–ª–∏ –≤ –∫–º
        }
      };
    }

    // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
    let sortOptions = {};
    switch (sort_by) {
      case 'rating':
        sortOptions = { 'ratings.average_rating': -1, 'ratings.total_reviews': -1 };
        break;
      case 'newest':
        sortOptions = { createdAt: -1 };
        break;
      case 'distance':
        if (lat && lng) {
          // MongoDB $near —Å–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞ –ø–æ —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—é
          sortOptions = { location: { $near: [parseFloat(lng), parseFloat(lat)] } };
        } else {
          sortOptions = { 'ratings.average_rating': -1 }; // –§–æ–ª–ª–±—ç–∫ –Ω–∞ —Ä–µ–π—Ç–∏–Ω–≥
        }
        break;
      case 'popular':
      default:
        sortOptions = { 'ratings.total_orders': -1, 'ratings.average_rating': -1 };
        break;
    }

    // –í—ã–ø–æ–ª–Ω—è–µ–º –∑–∞–ø—Ä–æ—Å —Å –ø–∞–≥–∏–Ω–∞—Ü–∏–µ–π
    const restaurants = await PartnerProfile.find(mongoFilter)
      .select({
        business_name: 1,
        category: 1,
        cuisine_types: 1,
        description: 1,
        avatar_image: 1,
        cover_image: 1,
        location: 1,
        ratings: 1,
        delivery_info: 1,
        working_hours: 1,
        'business_info.tags': 1,
        is_featured: 1,
        createdAt: 1
      })
      .sort(sortOptions)
      .limit(parseInt(limit))
      .skip(parseInt(offset))
      .lean(); // –î–ª—è –ª—É—á—à–µ–π –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

    // –ü–æ–ª—É—á–∞–µ–º –æ–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
    const total = await PartnerProfile.countDocuments(mongoFilter);

    // –û–±–æ–≥–∞—â–∞–µ–º –¥–∞–Ω–Ω—ã–µ –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π
    const enrichedRestaurants = await Promise.all(
      restaurants.map(async (restaurant) => {
        // –†–∞—Å—á–µ—Ç —Ä–∞—Å—Å—Ç–æ—è–Ω–∏—è –µ—Å–ª–∏ —É–∫–∞–∑–∞–Ω—ã –∫–æ–æ—Ä–¥–∏–Ω–∞—Ç—ã –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        let distance = null;
        if (lat && lng && restaurant.location?.coordinates) {
          distance = calculateDistance(
            lat, lng,
            restaurant.location.coordinates[1],
            restaurant.location.coordinates[0]
          );
        }

        // –ü–æ–ª—É—á–∞–µ–º –ø–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞ (—Ç–æ–ø-3)
        const popularProducts = await Product.find({
          partner_id: restaurant._id,
          is_active: true,
          is_available: true
        })
        .select('title price image_url category')
        .sort({ order_count: -1 })
        .limit(3)
        .lean();

        // –û–ø—Ä–µ–¥–µ–ª—è–µ–º —Å—Ç–∞—Ç—É—Å —Ä–∞–±–æ—Ç—ã
        const isOpenNow = checkRestaurantOpenNow(restaurant.working_hours);

        // –†–∞—Å—á–µ—Ç–Ω–æ–µ –≤—Ä–µ–º—è –¥–æ—Å—Ç–∞–≤–∫–∏
        const estimatedDeliveryTime = calculateEstimatedDelivery(
          distance,
          restaurant.delivery_info
        );

        return {
          id: restaurant._id,
          name: restaurant.business_name,
          category: restaurant.category,
          cuisine_types: restaurant.cuisine_types || [],
          description: restaurant.description,
          avatar_image: restaurant.avatar_image,
          cover_image: restaurant.cover_image,
          tags: restaurant.business_info?.tags || [],
          
          // –ì–µ–æ–ª–æ–∫–∞—Ü–∏—è
          location: {
            address: restaurant.location?.address,
            coordinates: restaurant.location?.coordinates,
            distance: distance ? `${distance.toFixed(1)} –∫–º` : null
          },
          
          // –†–µ–π—Ç–∏–Ω–≥–∏ –∏ –æ—Ç–∑—ã–≤—ã
          ratings: {
            average_rating: restaurant.ratings?.average_rating || 0,
            total_reviews: restaurant.ratings?.total_reviews || 0,
            total_orders: restaurant.ratings?.total_orders || 0
          },
          
          // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –¥–æ—Å—Ç–∞–≤–∫–µ
          delivery_info: {
            fee: restaurant.delivery_info?.delivery_fee || 0,
            min_order: restaurant.delivery_info?.min_order_amount || 0,
            estimated_time: estimatedDeliveryTime,
            free_delivery_from: restaurant.delivery_info?.free_delivery_from || null
          },
          
          // –°—Ç–∞—Ç—É—Å —Ä–∞–±–æ—Ç—ã
          is_open_now: isOpenNow,
          is_featured: restaurant.is_featured || false,
          
          // –ü–æ–ø—É–ª—è—Ä–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã
          popular_items: popularProducts.map(product => ({
            id: product._id,
            title: product.title,
            price: product.price,
            image_url: product.image_url,
            category: product.category
          }))
        };
      })
    );

    console.log('‚úÖ PUBLIC CATALOG SUCCESS:', {
      restaurants_found: restaurants.length,
      total_available: total,
      has_coordinates: !!(lat && lng),
      applied_filters: Object.keys(filters).length
    });

    return {
      restaurants: enrichedRestaurants,
      pagination: {
        total,
        limit: parseInt(limit),
        offset: parseInt(offset),
        has_more: (parseInt(offset) + restaurants.length) < total,
        total_pages: Math.ceil(total / parseInt(limit)),
        current_page: Math.floor(parseInt(offset) / parseInt(limit)) + 1
      },
      filters_applied: {
        category,
        search,
        location: lat && lng ? { lat, lng, radius } : null,
        sort_by,
        min_rating,
        delivery_fee_max,
        is_open_now
      }
    };

  } catch (error) {
    console.error('üö® GET PUBLIC CATALOG ERROR:', error);
    throw new Error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–∞—Ç–∞–ª–æ–≥–∞ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–æ–≤');
  }
};

/**
 * üç¥ –ü–û–õ–£–ß–ò–¢–¨ –î–ï–¢–ê–õ–ò –†–ï–°–¢–û–†–ê–ù–ê (–ø—É–±–ª–∏—á–Ω—ã–π –¥–æ—Å—Ç—É–ø)
 */
export const getPublicRestaurantDetails = async (restaurantId) => {
  try {
    console.log('üç¥ GET RESTAURANT DETAILS:', { restaurantId });

    if (!mongoose.isValidObjectId(restaurantId)) {
      throw new Error('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π ID —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞');
    }

    // –ü–æ–ª—É—á–∞–µ–º –¥–µ—Ç–∞–ª—å–Ω—É—é –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–µ
    const restaurant = await PartnerProfile.findOne({
      _id: restaurantId,
      is_active: true,
      is_approved: true,
      profile_status: 'approved'
    }).lean();

    if (!restaurant) {
      throw new Error('–†–µ—Å—Ç–æ—Ä–∞–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω');
    }

    // –ü–æ–ª—É—á–∞–µ–º —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Ç–æ–≤–∞—Ä–æ–≤
    const productsStats = await Product.aggregate([
      { $match: { partner_id: new mongoose.Types.ObjectId(restaurantId), is_active: true } },
      {
        $group: {
          _id: null,
          total_products: { $sum: 1 },
          available_products: { $sum: { $cond: ['$is_available', 1, 0] } },
          avg_price: { $avg: '$price' },
          min_price: { $min: '$price' },
          max_price: { $max: '$price' }
        }
      }
    ]);

    // –ü–æ–ª—É—á–∞–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ –æ—Ç–∑—ã–≤—ã
    const recentReviews = await mongoose.model('Review').find({
      partner_id: restaurantId
    })
    .sort({ createdAt: -1 })
    .limit(5)
    .populate('customer_id', 'username profile_image')
    .lean();

    // –°—Ç–∞—Ç—É—Å —Ä–∞–±–æ—Ç—ã
    const isOpenNow = checkRestaurantOpenNow(restaurant.working_hours);

    const stats = productsStats[0] || {
      total_products: 0,
      available_products: 0,
      avg_price: 0,
      min_price: 0,
      max_price: 0
    };

    console.log('‚úÖ RESTAURANT DETAILS SUCCESS:', {
      restaurant_name: restaurant.business_name,
      products_count: stats.total_products,
      reviews_count: recentReviews.length
    });

    return {
      id: restaurant._id,
      name: restaurant.business_name,
      category: restaurant.category,
      cuisine_types: restaurant.cuisine_types || [],
      description: restaurant.description,
      
      // –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è
      avatar_image: restaurant.avatar_image,
      cover_image: restaurant.cover_image,
      gallery: restaurant.gallery || [],
      
      // –ö–æ–Ω—Ç–∞–∫—Ç—ã –∏ –∞–¥—Ä–µ—Å
      contact_info: {
        phone: restaurant.contact_info?.phone,
        email: restaurant.contact_info?.email,
        website: restaurant.contact_info?.website
      },
      
      location: {
        address: restaurant.location?.address,
        coordinates: restaurant.location?.coordinates,
        zone: restaurant.location?.zone
      },
      
      // –í—Ä–µ–º—è —Ä–∞–±–æ—Ç—ã
      working_hours: restaurant.working_hours,
      is_open_now: isOpenNow,
      
      // –†–µ–π—Ç–∏–Ω–≥–∏ –∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞
      ratings: {
        average_rating: restaurant.ratings?.average_rating || 0,
        total_reviews: restaurant.ratings?.total_reviews || 0,
        total_orders: restaurant.ratings?.total_orders || 0,
        rating_breakdown: restaurant.ratings?.rating_breakdown || {}
      },
      
      // –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –¥–æ—Å—Ç–∞–≤–∫–µ
      delivery_info: {
        fee: restaurant.delivery_info?.delivery_fee || 0,
        min_order: restaurant.delivery_info?.min_order_amount || 0,
        max_distance: restaurant.delivery_info?.max_delivery_distance || 10,
        estimated_time: restaurant.delivery_info?.estimated_delivery_time || '30-45',
        free_delivery_from: restaurant.delivery_info?.free_delivery_from || null,
        delivery_zones: restaurant.delivery_info?.delivery_zones || []
      },
      
      // –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞ —Ç–æ–≤–∞—Ä–æ–≤
      menu_stats: {
        total_products: stats.total_products,
        available_products: stats.available_products,
        price_range: stats.min_price && stats.max_price ? 
          `${stats.min_price}‚ÇΩ - ${stats.max_price}‚ÇΩ` : null,
        average_price: stats.avg_price ? `${stats.avg_price.toFixed(0)}‚ÇΩ` : null
      },
      
      // –ü–æ—Å–ª–µ–¥–Ω–∏–µ –æ—Ç–∑—ã–≤—ã
      recent_reviews: recentReviews.map(review => ({
        id: review._id,
        customer_name: review.customer_id?.username || '–ê–Ω–æ–Ω–∏–º',
        customer_avatar: review.customer_id?.profile_image,
        rating: review.rating,
        comment: review.comment,
        created_at: review.createdAt,
        photos: review.photos || []
      })),
      
      // –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–∞—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è
      business_info: {
        registration_year: restaurant.business_info?.registration_year,
        tags: restaurant.business_info?.tags || [],
        special_features: restaurant.business_info?.special_features || []
      },
      
      is_featured: restaurant.is_featured || false,
      created_at: restaurant.createdAt
    };

  } catch (error) {
    console.error('üö® GET RESTAURANT DETAILS ERROR:', error);
    
    if (error.message.includes('–Ω–∞–π–¥–µ–Ω') || error.message.includes('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π')) {
      throw error;
    }
    
    throw new Error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–µ');
  }
};

/**
 * üìã –ü–û–õ–£–ß–ò–¢–¨ –ú–ï–ù–Æ –†–ï–°–¢–û–†–ê–ù–ê (–ø—É–±–ª–∏—á–Ω—ã–π –¥–æ—Å—Ç—É–ø)
 */
export const getPublicRestaurantMenu = async (restaurantId, filters = {}) => {
  try {
    const {
      category = null,
      search = null,
      sort_by = 'default', // default, price_asc, price_desc, popular, name
      is_available_only = true,
      limit = 50,
      offset = 0
    } = filters;

    console.log('üìã GET RESTAURANT MENU:', {
      restaurantId,
      category,
      search: search ? search.substring(0, 20) : null,
      sort_by
    });

    if (!mongoose.isValidObjectId(restaurantId)) {
      throw new Error('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π ID —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞');
    }

    // –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞
    const restaurant = await PartnerProfile.findOne({
      _id: restaurantId,
      is_active: true,
      is_approved: true
    }).lean();

    if (!restaurant) {
      throw new Error('–†–µ—Å—Ç–æ—Ä–∞–Ω –Ω–µ –Ω–∞–π–¥–µ–Ω –∏–ª–∏ –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω');
    }

    // –ë–∞–∑–æ–≤—ã–π —Ñ–∏–ª—å—Ç—Ä –¥–ª—è –ø—Ä–æ–¥—É–∫—Ç–æ–≤
    let productFilter = {
      partner_id: new mongoose.Types.ObjectId(restaurantId),
      is_active: true
    };

    // –ü–æ–∫–∞–∑—ã–≤–∞—Ç—å —Ç–æ–ª—å–∫–æ –¥–æ—Å—Ç—É–ø–Ω—ã–µ —Ç–æ–≤–∞—Ä—ã
    if (is_available_only) {
      productFilter.is_available = true;
    }

    // –§–∏–ª—å—Ç—Ä –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —Ç–æ–≤–∞—Ä–æ–≤
    if (category && category !== 'all') {
      productFilter.category = category;
    }

    // –ü–æ–∏—Å–∫ –ø–æ –Ω–∞–∑–≤–∞–Ω–∏—é —Ç–æ–≤–∞—Ä–∞
    if (search && search.trim()) {
      const searchRegex = new RegExp(search.trim(), 'i');
      productFilter.$or = [
        { title: searchRegex },
        { description: searchRegex },
        { category: searchRegex },
        { tags: { $in: [searchRegex] } }
      ];
    }

    // –°–æ—Ä—Ç–∏—Ä–æ–≤–∫–∞
    let sortOptions = {};
    switch (sort_by) {
      case 'price_asc':
        sortOptions = { price: 1 };
        break;
      case 'price_desc':
        sortOptions = { price: -1 };
        break;
      case 'popular':
        sortOptions = { order_count: -1, rating: -1 };
        break;
      case 'name':
        sortOptions = { title: 1 };
        break;
      case 'default':
      default:
        sortOptions = { display_order: 1, createdAt: -1 };
        break;
    }

    // –ü–æ–ª—É—á–∞–µ–º –ø—Ä–æ–¥—É–∫—Ç—ã
    const products = await Product.find(productFilter)
      .sort(sortOptions)
      .limit(parseInt(limit))
      .skip(parseInt(offset))
      .lean();

    // –û–±—â–µ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ –¥–ª—è –ø–∞–≥–∏–Ω–∞—Ü–∏–∏
    const total = await Product.countDocuments(productFilter);

    // –ü–æ–ª—É—á–∞–µ–º –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ —Ç–æ–≤–∞—Ä–æ–≤ —ç—Ç–æ–≥–æ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞
    const categories = await Product.distinct('category', {
      partner_id: new mongoose.Types.ObjectId(restaurantId),
      is_active: true,
      is_available: true
    });

    // –ì—Ä—É–ø–ø–∏—Ä—É–µ–º —Ç–æ–≤–∞—Ä—ã –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
    const menuByCategories = categories.map(categoryName => {
      const categoryProducts = products.filter(product => product.category === categoryName);
      
      return {
        category_name: categoryName,
        products_count: categoryProducts.length,
        products: categoryProducts.map(product => ({
          id: product._id,
          title: product.title,
          description: product.description,
          price: product.price,
          old_price: product.old_price,
          image_url: product.image_url,
          category: product.category,
          is_available: product.is_available,
          estimated_cooking_time: product.estimated_cooking_time,
          
          // –û–ø—Ü–∏–∏ —Ç–æ–≤–∞—Ä–∞ (—Ä–∞–∑–º–µ—Ä—ã, –¥–æ–±–∞–≤–∫–∏)
          options: product.options || [],
          
          // –†–µ–π—Ç–∏–Ω–≥ –∏ –ø–æ–ø—É–ª—è—Ä–Ω–æ—Å—Ç—å
          rating: product.rating || 0,
          order_count: product.order_count || 0,
          
          // –¢–µ–≥–∏ –∏ –º–µ—Ç–∫–∏
          tags: product.tags || [],
          is_spicy: product.is_spicy || false,
          is_vegetarian: product.is_vegetarian || false,
          is_new: product.is_new || false,
          is_popular: product.is_popular || false,
          
          // –ü–∏—â–µ–≤–∞—è —Ü–µ–Ω–Ω–æ—Å—Ç—å
          nutritional_info: product.nutritional_info || null
        }))
      };
    }).filter(category => category.products.length > 0);

    console.log('‚úÖ RESTAURANT MENU SUCCESS:', {
      restaurant_name: restaurant.business_name,
      categories_count: categories.length,
      products_count: products.length,
      total_products: total
    });

    return {
      restaurant: {
        id: restaurant._id,
        name: restaurant.business_name,
        category: restaurant.category,
        is_open_now: checkRestaurantOpenNow(restaurant.working_hours),
        delivery_info: restaurant.delivery_info
      },
      
      menu: {
        categories_count: categories.length,
        total_products: total,
        available_products: products.length,
        categories: menuByCategories
      },
      
      pagination: {
        total,
        limit: parseInt(limit),
        offset: parseInt(offset),
        has_more: (parseInt(offset) + products.length) < total,
        current_page: Math.floor(parseInt(offset) / parseInt(limit)) + 1
      },
      
      filters_applied: {
        category,
        search,
        sort_by,
        is_available_only
      }
    };

  } catch (error) {
    console.error('üö® GET RESTAURANT MENU ERROR:', error);
    
    if (error.message.includes('–Ω–∞–π–¥–µ–Ω') || error.message.includes('–ù–µ–∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π')) {
      throw error;
    }
    
    throw new Error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –º–µ–Ω—é —Ä–µ—Å—Ç–æ—Ä–∞–Ω–∞');
  }
};

/**
 * üîç –ü–û–ò–°–ö –†–ï–°–¢–û–†–ê–ù–û–í –ò –ë–õ–Æ–î
 */
export const searchPublicContent = async (searchQuery, filters = {}) => {
  try {
    const {
      search_type = 'all', // all, restaurants, dishes
      lat = null,
      lng = null,
      radius = 10,
      limit = 20
    } = filters;

    console.log('üîç PUBLIC SEARCH:', {
      query: searchQuery.substring(0, 30),
      search_type,
      has_location: !!(lat && lng)
    });

    if (!searchQuery || searchQuery.trim().length < 2) {
      throw new Error('–ó–∞–ø—Ä–æ—Å –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å –º–∏–Ω–∏–º—É–º 2 —Å–∏–º–≤–æ–ª–∞');
    }

    const searchRegex = new RegExp(searchQuery.trim(), 'i');
    const results = {
      restaurants: [],
      dishes: [],
      total_found: 0
    };

    // –ü–æ–∏—Å–∫ —Ä–µ—Å—Ç–æ—Ä–∞–Ω–æ–≤
    if (search_type === 'all' || search_type === 'restaurants') {
      let restaurantFilter = {
        is_active: true,
        is_approved: true,
        $or: [
          { business_name: searchRegex },
          { description: searchRegex },
          { category: searchRegex },
          { cuisine_types: { $in: [searchRegex] } }
        ]
      };

      // –ì–µ–æ—Ñ–∏–ª—å—Ç—Ä –¥–ª—è —Ä–µ—Å—Ç–æ—Ä–∞–Ω–æ–≤
      if (lat && lng && radius > 0) {
        restaurantFilter['location.coordinates'] = {
          $geoWithin: {
            $centerSphere: [[parseFloat(lng), parseFloat(lat)], radius / 6378.1]
          }
        };
      }

      const restaurants = await PartnerProfile.find(restaurantFilter)
        .select('business_name category description avatar_image ratings delivery_info location')
        .sort({ 'ratings.average_rating': -1 })
        .limit(parseInt(limit))
        .lean();

      results.restaurants = restaurants.map(restaurant => ({
        id: restaurant._id,
        name: restaurant.business_name,
        category: restaurant.category,
        description: restaurant.description,
        avatar_image: restaurant.avatar_image,
        rating: restaurant.ratings?.average_rating || 0,
        delivery_fee: restaurant.delivery_info?.delivery_fee || 0,
        type: 'restaurant'
      }));
    }

    // –ü–æ–∏—Å–∫ –±–ª—é–¥
    if (search_type === 'all' || search_type === 'dishes') {
      const dishesAggregation = await Product.aggregate([
        {
          $match: {
            is_active: true,
            is_available: true,
            $or: [
              { title: searchRegex },
              { description: searchRegex },
              { category: searchRegex },
              { tags: { $in: [searchRegex] } }
            ]
          }
        },
        {
          $lookup: {
            from: 'partnerprofiles',
            localField: 'partner_id',
            foreignField: '_id',
            as: 'restaurant'
          }
        },
        {
          $unwind: '$restaurant'
        },
        {
          $match: {
            'restaurant.is_active': true,
            'restaurant.is_approved': true
          }
        },
        {
          $project: {
            title: 1,
            description: 1,
            price: 1,
            image_url: 1,
            category: 1,
            rating: 1,
            restaurant_id: '$restaurant._id',
            restaurant_name: '$restaurant.business_name',
            restaurant_category: '$restaurant.category',
            restaurant_avatar: '$restaurant.avatar_image'
          }
        },
        {
          $sort: { rating: -1, order_count: -1 }
        },
        {
          $limit: parseInt(limit)
        }
      ]);

      results.dishes = dishesAggregation.map(dish => ({
        id: dish._id,
        title: dish.title,
        description: dish.description,
        price: dish.price,
        image_url: dish.image_url,
        category: dish.category,
        rating: dish.rating || 0,
        restaurant: {
          id: dish.restaurant_id,
          name: dish.restaurant_name,
          category: dish.restaurant_category,
          avatar_image: dish.restaurant_avatar
        },
        type: 'dish'
      }));
    }

    results.total_found = results.restaurants.length + results.dishes.length;

    console.log('‚úÖ PUBLIC SEARCH SUCCESS:', {
      restaurants_found: results.restaurants.length,
      dishes_found: results.dishes.length,
      total_found: results.total_found
    });

    return results;

  } catch (error) {
    console.error('üö® PUBLIC SEARCH ERROR:', error);
    throw new Error('–û—à–∏–±–∫–∞ –ø–æ–∏—Å–∫–∞');
  }
};

/**
 * üìÇ –ü–û–õ–£–ß–ò–¢–¨ –ö–ê–¢–ï–ì–û–†–ò–ò –†–ï–°–¢–û–†–ê–ù–û–í
 */
export const getPublicRestaurantCategories = async () => {
  try {
    console.log('üìÇ GET RESTAURANT CATEGORIES');

    // –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ —É–Ω–∏–∫–∞–ª—å–Ω—ã–µ –∫–∞—Ç–µ–≥–æ—Ä–∏–∏ –∞–∫—Ç–∏–≤–Ω—ã—Ö —Ä–µ—Å—Ç–æ—Ä–∞–Ω–æ–≤
    const categoriesAggregation = await PartnerProfile.aggregate([
      {
        $match: {
          is_active: true,
          is_approved: true,
          profile_status: 'approved'
        }
      },
      {
        $group: {
          _id: '$category',
          count: { $sum: 1 },
          avg_rating: { $avg: '$ratings.average_rating' },
          total_orders: { $sum: '$ratings.total_orders' }
        }
      },
      {
        $sort: { count: -1 }
      }
    ]);

    const categories = categoriesAggregation.map(cat => ({
      name: cat._id,
      restaurants_count: cat.count,
      average_rating: cat.avg_rating ? parseFloat(cat.avg_rating.toFixed(1)) : 0,
      total_orders: cat.total_orders || 0,
      // –î–æ–±–∞–≤–ª—è–µ–º —ç–º–æ–¥–∑–∏ –¥–ª—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π
      emoji: getCategoryEmoji(cat._id)
    }));

    console.log('‚úÖ CATEGORIES SUCCESS:', {
      categories_count: categories.length,
      total_restaurants: categoriesAggregation.reduce((sum, cat) => sum + cat.count, 0)
    });

    return {
      categories,
      total_categories: categories.length,
      total_restaurants: categoriesAggregation.reduce((sum, cat) => sum + cat.count, 0)
    };

  } catch (error) {
    console.error('üö® GET CATEGORIES ERROR:', error);
    throw new Error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –∫–∞—Ç–µ–≥–æ—Ä–∏–π');
  }
};

/**
 * ‚≠ê –ü–û–õ–£–ß–ò–¢–¨ –ü–û–ü–£–õ–Ø–†–ù–´–ï –†–ï–°–¢–û–†–ê–ù–´
 */
export const getPopularRestaurants = async (limit = 10) => {
  try {
    console.log('‚≠ê GET POPULAR RESTAURANTS:', { limit });

    const popularRestaurants = await PartnerProfile.find({
      is_active: true,
      is_approved: true,
      profile_status: 'approved'
    })
    .select('business_name category cuisine_types avatar_image ratings delivery_info is_featured')
    .sort({ 
      'ratings.total_orders': -1,
      'ratings.average_rating': -1,
      is_featured: -1
    })
    .limit(parseInt(limit))
    .lean();

    const results = popularRestaurants.map(restaurant => ({
      id: restaurant._id,
      name: restaurant.business_name,
      category: restaurant.category,
      cuisine_types: restaurant.cuisine_types || [],
      avatar_image: restaurant.avatar_image,
      rating: restaurant.ratings?.average_rating || 0,
      total_orders: restaurant.ratings?.total_orders || 0,
      total_reviews: restaurant.ratings?.total_reviews || 0,
      delivery_fee: restaurant.delivery_info?.delivery_fee || 0,
      is_featured: restaurant.is_featured || false
    }));

    console.log('‚úÖ POPULAR RESTAURANTS SUCCESS:', {
      restaurants_found: results.length
    });

    return {
      restaurants: results,
      total: results.length
    };

  } catch (error) {
    console.error('üö® GET POPULAR RESTAURANTS ERROR:', error);
    throw new Error('–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è –ø–æ–ø—É–ª—è—Ä–Ω—ã—Ö —Ä–µ—Å—Ç–æ—Ä–∞–Ω–æ–≤');
  }
};

// ================ –£–¢–ò–õ–ò–¢–ê–†–ù–´–ï –§–£–ù–ö–¶–ò–ò ================

/**
 * üìç –†–ê–°–ß–ï–¢ –†–ê–°–°–¢–û–Ø–ù–ò–Ø –ú–ï–ñ–î–£ –î–í–£–ú–Ø –¢–û–ß–ö–ê–ú–ò
 */
const calculateDistance = (lat1, lng1, lat2, lng2) => {
  const R = 6371; // –†–∞–¥–∏—É—Å –ó–µ–º–ª–∏ –≤ –∫–º
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLng = (lng2 - lng1) * Math.PI / 180;
  const a = 
    Math.sin(dLat / 2) * Math.sin(dLat / 2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
    Math.sin(dLng / 2) * Math.sin(dLng / 2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
};

/**
 * üïí –ü–†–û–í–ï–†–ö–ê –†–ê–ë–û–¢–ê–ï–¢ –õ–ò –†–ï–°–¢–û–†–ê–ù –°–ï–ô–ß–ê–°
 */
const checkRestaurantOpenNow = (workingHours) => {
  if (!workingHours) return false;
  
  const now = new Date();
  const currentDay = now.toLocaleDateString('en-US', { weekday: 'lowercase' });
  const currentTime = now.toTimeString().slice(0, 5); // HH:MM —Ñ–æ—Ä–º–∞—Ç
  
  const todayHours = workingHours[currentDay];
  if (!todayHours || !todayHours.is_open) {
    return false;
  }
  
  const openTime = todayHours.open_time;
  const closeTime = todayHours.close_time;
  
  if (!openTime || !closeTime) return false;
  
  // –°—Ä–∞–≤–Ω–∏–≤–∞–µ–º –≤—Ä–µ–º—è (–ø—Ä–æ—Å—Ç–æ–µ —Å—Ç—Ä–æ–∫–æ–≤–æ–µ —Å—Ä–∞–≤–Ω–µ–Ω–∏–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –¥–ª—è HH:MM)
  return currentTime >= openTime && currentTime <= closeTime;
};

/**
 * üöö –†–ê–°–ß–ï–¢ –í–†–ï–ú–ï–ù–ò –î–û–°–¢–ê–í–ö–ò
 */
const calculateEstimatedDelivery = (distance, deliveryInfo) => {
  const baseTime = 25; // –ë–∞–∑–æ–≤–æ–µ –≤—Ä–µ–º—è –ø—Ä–∏–≥–æ—Ç–æ–≤–ª–µ–Ω–∏—è
  let deliveryTime = 15; // –ë–∞–∑–æ–≤–æ–µ –≤—Ä–µ–º—è –¥–æ—Å—Ç–∞–≤–∫–∏
  
  if (distance) {
    deliveryTime += Math.ceil(distance * 2); // 2 –º–∏–Ω—É—Ç—ã –Ω–∞ –∫–º
  }
  
  const totalTime = baseTime + deliveryTime;
  const minTime = Math.max(totalTime - 10, 20);
  const maxTime = totalTime + 15;
  
  return `${minTime}-${maxTime} –º–∏–Ω`;
};

/**
 * üé≠ –ü–û–õ–£–ß–ò–¢–¨ –≠–ú–û–î–ó–ò –î–õ–Ø –ö–ê–¢–ï–ì–û–†–ò–ò
 */
const getCategoryEmoji = (category) => {
  const emojiMap = {
    '–ü–∏—Ü—Ü–∞': 'üçï',
    '–°—É—à–∏': 'üç£',
    '–ë—É—Ä–≥–µ—Ä—ã': 'üçî',
    '–ò—Ç–∞–ª—å—è–Ω—Å–∫–∞—è –∫—É—Ö–Ω—è': 'üçù',
    '–ê–∑–∏–∞—Ç—Å–∫–∞—è –∫—É—Ö–Ω—è': 'ü•¢',
    '–†—É—Å—Å–∫–∞—è –∫—É—Ö–Ω—è': 'ü•ü',
    '–î–µ—Å–µ—Ä—Ç—ã': 'üç∞',
    '–ö–æ—Ñ–µ': '‚òï',
    '–ó–∞–≤—Ç—Ä–∞–∫–∏': 'ü•û',
    '–ó–¥–æ—Ä–æ–≤–æ–µ –ø–∏—Ç–∞–Ω–∏–µ': 'ü•ó',
    '–®–∞—à–ª—ã–∫': 'üçñ',
    '–ú–æ—Ä–µ–ø—Ä–æ–¥—É–∫—Ç—ã': 'ü¶ê',
    '–í–µ–≥–µ—Ç–∞—Ä–∏–∞–Ω—Å–∫–æ–µ': 'üå±',
    '–§–∞—Å—Ç—Ñ—É–¥': 'üåÆ',
    '–ö–∏—Ç–∞–π—Å–∫–∞—è –∫—É—Ö–Ω—è': 'ü•°',
    '–Ø–ø–æ–Ω—Å–∫–∞—è –∫—É—Ö–Ω—è': 'üç±',
    '–ì—Ä—É–∑–∏–Ω—Å–∫–∞—è –∫—É—Ö–Ω—è': 'ü´ì',
    '–ú–µ–∫—Å–∏–∫–∞–Ω—Å–∫–∞—è –∫—É—Ö–Ω—è': 'üåØ',
    '–ò–Ω–¥–∏–π—Å–∫–∞—è –∫—É—Ö–Ω—è': 'üçõ',
    '–í—ã–ø–µ—á–∫–∞': 'ü•ñ'
  };
  
  return emojiMap[category] || 'üçΩÔ∏è';
};